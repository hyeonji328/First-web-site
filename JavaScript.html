<!doctype html>
<html>
<head>
    <title>WEB1 - JavaScript</title>
    <meta charset="utf-8">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5XTC326PSJ"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-5XTC326PSJ');
    </script>
    <link rel="stylesheet" href="style.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gowun+Batang&display=swap" rel="stylesheet">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script> <!--script 태그를 이용해서 구글에서 제공하는 jquery 라이브러리를 페이지에 삽입한 것.-->
    <script src="colors.js"></script>
    <link rel="import" href="toc.html">
</head>
<body>
    <h1><a href="index.html" id="night">WEB</a></h1>
    <input type="button" value="night" onclick="
        nightDayHandler(this);
    ">
    <div id="grid">
        <div id="tocContainer"></div>
        <script>
            document.addEventListener('DOMContentLoaded', function(){
                fetch('toc.html')
                    .then(response => response.text())
                    .then(data => {
                        document.getElementById('tocContainer').innerHTML = data;
                        highlightCurrentPageLink();
                });
            });

            function highlightCurrentPageLink() {
                var links = document.querySelectorAll('#tocContainer a');
                var currentPage = window.location.pathname.split('/').pop();
                
                links.forEach(function(link) {
                    if (link.href.endsWith(currentPage)) {
                        link.classList.add('current-page');
                    }
                });
            }
            // links 변수: id값이 #tocContainer인 태그 안의 a 태그가 모두 선택됨.
            // currentPage 변수: window.location.pathname이라는 property에서 split 함수를 이용해 /를 기준으로 파일명을 나누고, pop 메소드로 파일명의 가장 마지막 요소를 반환함.
            // window.location.pathname 속성: 현재 URL의 이름 중 도메인 이름을 제외한 경로를 포함함. 예를 들어 URL이 'https://example.com/path/to/your/page.html'라면 window.location.pathname은 '/path/to/your/page.html'이 되는 것.
            // forEach 메소드: 배열의 각 요소에 콜백 함수를 요소의 수만큼 실행하는 메소드. 인자 값으로 콜백 함수를 넣을 수 있음.
            // links.forEach(function(link): 변수 links에 forEach 메소드를 적용하면 변수 links의 결과인 모든 a태그에 대해서 콜백 함수가 실행됨. endsWtih 메소드를 이용해 링크의 href가 변수 currentPage와 똑같이 끝나는지 확인함. 똑같이 끝나서 결과값으로 참을 도출하면 조건문의 조건식이 참이 되어 조건문의 코드가 실행됨. classList 속성을 사용했기 때문에 link의 현재 css class 목록이 반환되고, add 메소드에 의해 지정한 클래스 값인 current-page가 class 목록에 추가됨. 
        </script>
        <div id="article">
            <h2>JavaScript</h2>
                <P>html은 한번 출력되면 더 이상 스스로를 바꿀 수 있는 기능이 없음. 이걸 가능하게 해 주는 게 JavaScript. 사용자가 웹페이지와 상호작용하게 해 주는 언어. 자바스크립트는 html을 제어하는 언어이며 웹페이지를 보다 동적으로 만들어 줌. 따라서 기본적으로 자바스크립트는 html 위에서 동작하는 언어.</P>
                <p>html의 script 태그를 이용해서 사용함. 이 태그 안에는 자바스크립트의 코드가 오기로 약속되어 있기에 브라우저는 태그 안의 코드를 자바스크립트로 해석함.</p>
                <p>콘솔을 이용할 수도 있음. 마우스 오른쪽 키에서 '검사-콘솔'을 사용해 파일을 만들지 않고 즉석에서 자바스크립트를 실행할 수 있음. 여러 가지 데이터를 처리하는 데 사용할 수 있음. elements 창에서 esc를 눌러 console을 동시에 볼 수 있음. 콘솔 창에서 위 화살표를 누르면 바로 위에 쓴 값을 복사 붙여넣기 할 수 있음. 현재 보고 있는 웹페이지에 한해 자바스크립트를 실행하기 때문에 빠르고 간단하게, 필요에 맞게 자바스크립트를 사용할 수 있다는 장점이 있음. ex: length 코드를 이용해 문자열의 문자 수를 세고 alert 창으로 띄우게 하기.</p>
            <h2><a href="ex1.html" title="자바스크립트 예제"><u>예시</u></a></h2>-> 링크 참고
            <h2>이벤트</h2>웹브라우저 위에서 어떠한 사건(event)가 일어났을 때 웹페이지가 반응하게 하는 html의 속성들. 이벤트를 사용해 사건이 일어났을 때 즉, 사용자가 웹브라우저에서 어떤 행동을 했을 때 웹페이지가 반응하게 하는 것. 자바스크립트가 사용자와 상호작용하는 데 핵심적인 역할을 하며, 이벤트들을 이용해서 사용자와 상호작용하는 웹페이지를 만들 수 있음. 이벤트 속성의 속성값에는 자바스크립트 코드가 들어가야 함.
                <ul>
                    <li>onclick: 사용자가 클릭하면 속성값에 있는 코드를 자바스크립트로 해석해 실행하게 하는 속성.</li>
                    <li>onchange: 해당 속성이 포함된 태그의 내용이 변경되었을 때 자바스크립트를 실행하는 속성.</li>
                    <li>onkeydown: 해당 속성이 있는 태그 영역에서 키보드가 눌렸을 때 반응하여 동작하는 속성. 자동검색어나 오탈자 방지 등을 위해 사용함.</li>
                </ul>
            <h2>자료형(data type)</h2>프로그래밍 언어에서 사용할 수 있는 데이터의 종류
                <ul>
                    <li>숫자 number: 숫자 그대로 표현됨. 산술 연산자(+, -, *, /)를 이용해 콘솔에서 계산할 수 있음.</li>
                    <li>문자열 string: 문자는 따옴표로 감싸서 표현함. 작은따옴표와 큰따옴표 모두 쓸 수 있지만 문자의 앞뒤 따옴표를 같은 걸로 통일해 써야 함. properties와 methods 명령을 사용해 문자 데이터를 처리할 수 있음. // properties ex: '.length'를 이용하면 문자열 내의 문자 수를 세어 줌 // methods ex: '.toUpperCase()'를 활용하면 문자열의 문자를 대문자로 변환해 줌. '.indexOf()를 쓰면 주어진 값과 일치하는(해당 값이 있는) 첫 번째 인덱스를 반환하고, 없으면 -1을 반환함. trim은 공백 삭제.</li>
                    <li>Boolean: true와 false 단 두 개의 데이터만 가지고 있는 데이터 타입. 반복을 제거하는 데 쓸 수 있음.</li>
                    <li>배열: 많은 데이터를 특정 기준에 따라 정리하는 것. Literal(기호)은 [], [] 안에 값을 적고, 콤마로 구분하여 여러 개의 값을 적을 수 있음. 배열에서 각각의 항목은 원소(element)로 부름. 배열의 값을 셀 때는 index라 칭하고, 첫 번째 인덱스는 0번부터 카운트함. 배열에서 원하는 원소값을 불러오고 싶을 때 [] 안에 인덱스 값을 넣어서 불러옴. <a href="ex4.html" title="배열 예시"><u>예시 링크</u></a></li> -> 예시 설명: 배열만 있으면 쓰기 불편하기 때문에 변수를 만들어 변수 안에 배열이라는 데이터타입을 넣고, 변수의 이름을 활용해 배열의 값을 불러온 것. 그리고 명령어인 length를 활용해 배열의 인덱스 수를 카운트하고, push를 이용해 배열을 추가함. 이와 같이 배열에는 다양한 명령어가 있음.
                </ul>
            <h2>변수(variable) VS. 상수(constant)</h2>변수와 변수명만 쓰면 '변수를 선언한 것', 선언한 변수에 값을 넣으면 '초기화 or 할당한 것'.
                <ul>
                    <li>변수: 바뀔 수 있는 어떠한 값. ex: x, y. 'var 변수 이름' 형태로 선언하고, var이 없어도 실행되지만 쓰는 게 더 좋은 습관. 어떤 데이터에서 바뀔 가능성이 있거나 때에 따라 바꾸어야 하는 부분이 있을 때 그 부분을 변수 처리하면 매번 바꿀 필요가 없어짐.</li>
                    <li>상수: 절대 변하지 않는 고정된 값. ex: 숫자 1. 'const 상수 이름' 형태로 선언함.</li>
                </ul>
                </ul>
            <h2>연산자(Operator)</h2>계산을 돕는 기호들.
                <ul>
                    <li>산술 연산자(이항 연산자): 수식을 계산하게 해 주는 연산자. 왼쪽, 오른쪽 두 개의 항을 계산하는 연산자라 이항 연산자라고도 부름. 대표적인 것이 사칙연산 +, -, *(곱하기), /(나누기).</li>
                    <li>대입 연산자: 오른쪽 항의 값을 왼쪽 항에 대입하는 연산자. ex: =.</li>
                    <li>비교 연산자(Comparison operator): 좌항과 우항을 결합해서 어떤 데이터를 만드는 이항 연산자. 좌항과 우항을 비교해 둘이 같다면 true, 다르다면 false의 값을 도출해 냄. true와 false를 묶어서 <strong>Boolean</strong>이라고 칭함. ex: ==, ===, 부등호. <a href="ex2.html" title="조건문 예시"><u>예시 링크</u></a></li>
                    <li>결합 연산자: 문자열을 합칠 때 사용하는 연산자. ex: +, +=(더하기할당 연산자. 오른쪽 피연산자의 값을 변수에 더한 결과를 다시 변수에 할당함).</li>
                </ul>
            <h2>제어할 태그 선택하기</h2>
                <p>document. 구문을 사용함. ex: document.write()는 괄호 안의 값을 문서에서 찾아 적으라는 뜻.</p>
                <P>CSS의 선택자를 이용하면 훨씬 편하고 정교하게 선택할 수 있음. document.querySelector('selectors'); 구문을 사용함. 이 문서(document)에서 CSS의 선택자(Selector/id, class, element 등)가 ('선택자명')인 태그를 질문(query)한다는 의미. querySelector는 같은 id나 class인 경우 스크립트의 최상단 요소 하나만을 선택함. 예시: document.querySelector(".myclass");는 클래스가 myclass인 태그를 선택하라는 의미. </P>
                <p>querySelector가 최상단 요소 하나만을 선택하는 것과 달리 querySelectorAll은 지정한 선택자명에 해당하는 모든 요소의 NodeList(배열과 비슷한 객체)를 반환함. 특정 요소는 빼고 선택하고 싶을 때는 선택자명에 :not()을 추가해서 예외 처리함. 예시: document.querySelectorAll('a:not(a.do)')는 스크립트 내에서 예외 처리된 'class가 do인 a 태그' 외의 나머지 모든 a 태그의 노드리스트를 반환함.</p>
                <p>CSS의 style을 JS로 주고 싶을 때는 .style을 사용함.</p>
                <p>value 값을 알고 싶을 때는 .value 사용.</p>
            <h2>리팩토링</h2>
                <p>코드가 동작하는 것은 그대로 두되, 코드 자체를 효율적으로 만들어 가독성을 높이고, 중복을 제거하고, 유지보수를 편리하게 하는 등 코드를 개선하는 작업. 소프트웨어가 커지고 복잡해지는 것에 따라 틈틈이 리팩토링을 해야 좋은 프로그램을 만들 수 있음.</p>
            <h2>파일로 쪼개서 정리하기</h2>
                <p>코드가 늘어나면 함수로 정리하고, 함수와 변수가 늘어나면 객체로 정리하듯이 객체가 늘어나면 서로 연관된 코드들을 여러 파일로 쪼개서 정리할 수 있음. js 파일을 만들어서 공통된 코드를 넣어 놓고, 웹페이지에는 script 코드로 js 파일을 링크해 놓으면 훨씬 더 명확하고 가독성 있는 코드를 쓸 수 있고, 이미 써 놓은 코드를 재사용하기도 용이해짐.</p>
                <p>캐시 측면에서도 장점이 있음. 웹 브라우저는 한번 다운로드한 파일을 컴퓨터에 저장하고, 다음에는 네트워크를 통하지 않고 저장된 파일을 읽어서 화면에 띄움. 이때 사용하는 것이 캐시. 그러면 서버 비용이 절감되고, 네트워크 트래픽을 줄이고 화면에 정보를 띄우는 속도가 빨라짐. 따라서 파일로 쪼개는 것이 효율적이고 돈과 시간을 절감할 수 있는 방법임.</p>
            <h2>조건문</h2>
                <p><a href="ex3.html" title="조건문 예시"><u>예시 링크</u></a></p>
                <p>구문: if(조건식){statement1} else if(조건식){statement2} else{statment3}. 조건식의 값은 Boolean 즉, 참이나 거짓이어야 함. 조건식이 참이라면 if문이나 else if문의 {}가 실행되고, 거짓이라면 else의 {}가 실행됨. else if에는 개수 제한이 따로 없음.</p>
            <h2>반복문(Loop)</h2>
                <p><a href="ex5.html" title="반복문 예시"><u>반복문 예시 링크</u></a></p>
                <p><a href="ex6.html" title="반복문 & 배열의 활용 예시"><u>반복문 & 배열 활용 예시 링크</u></a></p>
                <p>반복문의 기본 문법: while문, for문 등 다양하고 구문은 while/for () {}. () 안의 데이터타입은 불리언이고, 참일 때는 {}가 반복되고, 거짓일 때 반복이 종료됨. 따라서 언제 반복이 종료될지 지정하는 것이 중요함. 필수는 아니지만 관습적으로 변수 i를 활용해서 종료 시점을 정함(예시 참고).</p>
                <p>while과 for은 구문에서 차이가 남. for문은 구문에 initialization(초기화할 변수, var로 선언하면 반복문 밖에서도 사용 가능하고 let로 선언하면 for문 내에서만 사용함), condition(반복문을 수행할 초기화된 변수의 조건), final-expression(반복문 수행 후 수행할 조건/ex.i++)가 모두 포함되지만, while의 구문에는 조건만 포함되기 때문에 초기화할 변수를 따로 지정해 주고, {} 안에 반복될 코드를 적을 때 final-expression도 적어 줘야 함.</p>
            <h2>함수(Function)</h2>
                <a href="ex7.html" title="함수 예시"><u>예시 링크</u></a>
                <p>메소드라고도 부름. 문법은 <strong>function 함수명(){함수 내용}</strong>. 특정 목적의 작업을 수행하도록 설계된 독립적인 블록. 필요할 때마다 호출해 해당 작업을 반복해서 수행할 수 있음. 따라서 특정한 내용이 반복되는데 연속으로 반복되지 않아 반복문을 쓸 수 없을 때 함수를 사용할 수 있음(예시 참고).</p>
                <p>반복적으로 등장하는 코드를 정리하거나, 내용을 한눈에 알아보기 어려운 코드들을 함수화하여 이름을 부여할 때도 사용함.</p>
                <p>함수는 기본적으로 입력과 출력으로 이루어져 있음. 이때 입력과 관련된 것이 <strong>parameter 매개변수</strong>와 <strong>argument 인자</strong>고, 출력과 관련된 것이 <strong>return</strong>.</p>
                <p>함수에 입력하는 값에 따라서 출력되는 값이 다르게 하고 싶을 때 매개변수와 인자를 사용함. 함수를 호출할 때 괄호 안에 입력하는 값이 인자고, 함수를 만들 때 괄호 안에 넣는 매개변수가 이 인자값을 함수에 매개함. 이 변수를 활용해 입력에 따라 다른 결과를 얻을 수 있음. 여기까지만 하면 다양한 용도로 함수의 값을 사용하고 싶을 때 매번 해당 용도에 맞는 함수를 새로 만들어야 한다는 문제점이 생김. 이것을 보완해 줄 수 있는 게 출력을 담당하는 return. return문이 실행되면 현재 함수가 종료되고, return 뒤에 있는 값이 반환됨. 따라서 원하는 위치에 return문이 있는 함수를 호출하면 그곳에 return이 반환한 값이 들어가므로 다양한 용도로 활용할 수 있는 것. return을 활용하면 함수 하나만 만들어도 return이 함수의 값을 함수를 호출한 곳으로 반환하여 주기 때문에 함수 하나를 다양한 용도로 사용할 수 있음(예시 참고).</p>
                <ul>
                    <li>alert: 경고창을 띄우는 함수</li>
                </ul>
            <h2>객체(object)</h2>
                <a href="ex8.html" title="객체 예시"><u>예시 링크</u></a>
                <p>서로 연관된 함수, 변수들을 그룹핑해서 정리할 수 있는 일종의 수납 상자(폴더). 배열은 정보를 순서대로 담는 상자라면, 객체는 정보를 그룹핑해서 원하는 대로 담을 수 있는 상자. Object literal은 {}, '객체명.메소드'에서 메소드란 객체 내의 함수를 이르는 말.</p>
                <p>변수에 {}를 이용해 객체를 생성하고, document.write로 데이터를 불러올 수 있음. 중간에 데이터를 추가하는 것도 가능함. 데이터를 모두 불러올 때 배열에서 반복문을 쓴 것처럼, 객체에서는 for in문을 사용함. 변수를 활용해 속성명과 속성에 해당하는 데이터 값을 불러올 수 있음(예시 참고). for in문을 사용해 객체의 데이터를 순환하여 필요한 정보가 있는지 없는지를 살펴볼 수 있음.</p>
                <p><u>Property & Method</u>. Property는 객체에 소속된 변수, method는 객체에 소속된 함수를 일컫는 말. <br>-- 예시: var coworkers = {
                    'programmer':'Lucy',
                    'designer':'Emma' 
                };에서 programmer, designer가 속성이고 Lucy, Emma가 각각의 속성(key)과 짝을 이루는 값(value).</p>
                <p><strong>예시</strong><br>
                    var Body = {
                        setBackgroundColor: function(color) {
                            document.body.style.backgroundColor = color;
                        }
                    } <br>
                    이 객체를 호출하고 싶을 땐 Body.setBackgroundColor로 호출하면 됨. 그러면 브라우저가 문서 내에서 Body 객체가 정의된 대로 메소드(객체 내의 함수)를 실행하고, 이에 따라 메소드 안에 있는 함수의 매개변수 color에 인자 값이 적용되어 document.body.style.backgroundColor = color 코드가 실행됨.
                    </p>
            <h2>library VS. framwork</h2>
                    <p>공통적으로는 다른 사람과 협력하는 모델. 직접 코딩하는 것보다 좀 더 생산성이 증가함.</p>
                    <p>
                        <h4 style="margin-bottom: 5px;">library</h4>: 프로그램에 사용할 수 있는 소프트웨어가 잘 정리정돈되어 있어 원하는 걸 가져와서 사용할 수 있는 곳. 말하자면 부품이 모여 있는 곳. CDN(Content Delivery Network)을 이용하면 직접 라이브러리의 사용료를 지불하지 않고, 라이브러리의 서버에 정보를 저장 후 script src로 불러오는 방식으로 사용할 수 있음.
                        <p>
                            - jQuery: JavaScript의 라이브러리로 오래됐고 안정적인 라이브러리. jquery는 $로 시작함. $('a')는 $라는 이름의 함수. 이 코드는 웹페이지의 모든 a 태그를 제이쿼리로 제어하겠다는 뜻.
                        </p>
                    </p>
                    <p>
                        <h4 style="margin-bottom: 5px;">framwork</h4>:framwork라는 이미 만들어진 구조를 이용해 내가 만들고자 하는 프로그램의 공통적인 구조를 구성하고 원하는 기능을 수정하거나 추가하여, 프로그램을 처음부터 끝까지 만들지 않게 해 줌. 말하자면 반제품.
                    </p>
            <h2>UI VS. API</h2>
                    <p>
                        <h4 style="margin-bottom: 5px;">UI</h4>: User Interface. 사용자가 시스템을 제어하기 위해서 사용하는 조작 장치.
                    </p>
                    <p>
                        <h4 style="margin-bottom: 5px;">API</h4>: Application Programming Interface. 어플리케이션을 만들기 위해서 프로그래밍 할 때 사용하는 조작 장치.
                    </p>
            <h2>키워드</h2>
                <ul>
                    <li>this: 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 자기 참조 변수. this가 가리키는 값인 바인딩은 고정된 게 아니고, 함수를 어떻게 호출하느냐에 따라서 달라짐.</li>
                </ul>
            <h2>표현식(Expression)</h2>
            <p>예시: 1+1은 2에 대한 표현식. 1===1은 true에 대한 표현식. 2-1은 1에 대한 표현식.</p>
        </div>
    </div>
    <input type="button" value="night" onclick="
    var alist = document.querySelectorAll('a:not(ol.no a)')
    nightDayHandler(this)
    ">
<br><br><br><p>
        <div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://web1-grc8vaum39.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </p>
</body>
</html>